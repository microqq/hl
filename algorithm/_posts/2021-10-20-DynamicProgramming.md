---
layout: post
title:  "动态规划"
date:   2021-10-20
categories: 
    - algorithm
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

动态规划

- [1. 什么是动态规划](#1-什么是动态规划)
- [2. 怎么理解它](#2-怎么理解它)
  - [2.1 动态规划问题一般有几个特征[<sup>[1]</sup>](#refer-anchor-1)](#21-动态规划问题一般有几个特征sup1sup)
  - [2.2 动态规划算法的基本步骤](#22-动态规划算法的基本步骤)
- [3. 动态规划问题](#3-动态规划问题)
  - [3.1 硬币问题（最优型动态规划）](#31-硬币问题最优型动态规划)
  - [3.2 机器人路径问题（存在型动态规划）](#32-机器人路径问题存在型动态规划)
  - [3.3 背包问题](#33-背包问题)
- [参考](#参考)

#### 1. 什么是动态规划

动态规划是一种解决多阶段过程决策最优化问题的数学方法。

多阶段决策的过程可以按照空间或时间等划分成多个互相联系的阶段，每一个阶段都需要做出决策，决策的选取并不是任意的，它既依赖于当前的状态，又会影响以后阶段决策的发展，这种前后关联的多阶段决策过程就称为多阶段决策问题。

针对多阶段决策问题，20世纪50年代美国数学家Bellmen等人提出了著名的最优化原理，把多阶段过程划分为系列的单阶段过程，利用阶段之间的关联，逐个求解，从而创立了解决这类过程优化问题的新方法——动态规划。当每一个阶段局部决策都是最优的时候，所有阶段决策形成的决策序列就构成了最优全局决策。

动态规划是一种解决问题的方法，而不是一种特殊的解题途径，针对不同的最优化问题，其性质不同，得到最优解的条件也不相同，不存在一种万能的动态规划算法解决所有问题，视具体问题具体分析。

#### 2. 怎么理解它

##### 2.1 动态规划问题一般有几个特征[<sup>[1]</sup>](#refer-anchor-1)

- 最优子结构性质。

如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

- 无后效性。

即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

- 子问题重叠性质。

子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

##### 2.2 动态规划算法的基本步骤

- 确定状态。

“状态”是什么呢？动态规划在解决多阶段过程决策问题的时候，将其划分成一系列的单阶段决策问题，那么每一个单阶段的决策我们给它设定一个“状态”，比如 $f[i]$ 表示第 $i$ 个阶段的决策“状态”，比如“硬币问题”，状态 $f[i] = Y$ 就表示最少用 $Y$ 枚硬币可以拼出 $i$。
那么该怎么确定“状态”的表示呢？通常我们从多阶段决策问题的最后一个阶段入手，以最优解问题为例，要想使得最后阶段的决策状态 $f[N]$ 是最优的，那么必然要求上一个阶段决策状态 $f[N-1]$ 也是最优的，这样我们将原问题转化成了一个子问题，求解上一个阶段最优决策状态。最后寻找 $f[N]$ 与 $f[N-1]$ 之间的关联，确定“状态”表示，比如 $f[N] = f[N-1] + 1$。

- 确定状态转移方程。

就是要将子问题之间的“状态”关联转化为方程表达式。

- 确定初始条件和边界约束。

初始条件指的是我们计算开始时阶段的“初始状态”，边界约束是指我们处理非法值时的“非法状态”。

- 确定计算顺序。

我们知道多阶段决策问题，每个阶段决策状态都依赖于之前阶段决策状态，所以我们可以根据依赖关系来确定计算顺序，比如“硬币问题”，我们先计算 $f(0)$，然后计算 $f(1),f(2),...,f(i)$。

#### 3. 动态规划问题

##### 3.1 硬币问题（最优型动态规划）

- 问题描述（<https://www.lintcode.com/problem/669/>）：

  给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.  

        样例1
        输入：
        [1, 2, 5]
        11
        输出： 3
        解释： 11 = 5 + 5 + 1

        样例2
        输入：
        [2]
        3
        输出： -1

- 分析：
  - 确认状态。

  以样例 1 为例是，最后我们的目标是硬币总额等于11，并且硬币数量最少，我们可以设最后的“状态”为 $f(11) = X$, $X$ 表示最少硬币数量。假设最后一枚硬币是 $a_k(k = 1, 2, 5)$, 这样，要想使 $f(11)$ 数量最少，就要使 $f(11 - a_k)$ 数量最少，两者关联：$f(11) = f(11 - a_k) + 1$。最后一枚硬币 $a_k$ 面额可能是 1、2 和 5 其中之一。

  $$
  f(11) = X_1 = f(11 - 1) + 1,\\
  f(11) = X_2 = f(11 - 2) + 1,\\
  f(11) = X_3 = f(11 - 5) + 1.
  $$

  $f(11)$ 取 $X_1, X_2, X_3$ 中最优的结果。

  - 确定状态转移方程。

  状态方程 $f(i) = X$，自变量 $i$ 表示当前阶段总金额，因变量 $X$ 表示当前阶段硬币数量，状态转移方程为:

  $$
  f(i) = min(f(i - a_0) + 1, f(i- a_1) + 1, f(i - a_2) + 1,...,f(i - a_k) + 1).
  $$

  - 确定初始条件和边界约束。

  首先，从状态转移方程反推计算过程中，我们需要知道计算什么时候停下来，当硬币总额小于 0 时，找不到这样的面额去表示小于 0 的数，因此不需要继续计算了，并且当硬币总额等于 0 时，设 $f(0) = 0$即为初始条件。
  另外，参照状态转移方程，考虑:

  $$
  \begin{align*}
  f(1) &= min(f(1 - 1) + 1, f(1 - 2) + 1, f(1 - 5) + 1) \\
  &= min(f(0) + 1, f(-1) + 1, f(-4) + 1)
  \end{align*}
  $$

  $f(-1)、f(-4)$ 自变量分别等于 $-1、-4$，属于边界以外（小于0）的值，我们设定所有小于 0 的 $f(i) = \infty, (i < 0)$，可得:

  $$
  \begin{align*}
  f(1) &= min(f(1 - 1) + 1, f(1 - 2) + 1, f(1 - 5) + 1) \\
  &= min(f(0) + 1, f(-1) + 1, f(-4) + 1) \\
  &= min(1, \infty, \infty) \\
  &= 1.
  \end{align*}
  $$

- 代码实现：

```C++
    #include <vector>
    #include <limits>

    using namespace std;

    const int kIntMax = numeric_limits<int>::max();

    int coinChange(vector<int> &coins, int amount) {
        if (coins.size() == 0 || amount == 0) {
            return 0;
        }

        int *f = new int[amount + 1];
        f[0] = 0;
        for (int i = 1; i <= amount; i++) {
            f[i] = kIntMax;
            for (int j = 0, size = coins.size(); j < size; j++) {
                if (i >= coins[j] && f[i - coins[j]] != kIntMax) {
                    f[i] = min(f[i - coins[j]] + 1, f[i]);
                }
            }
        }

        int ret = f[amount];
        delete[] f;

        if (ret == kIntMax) {
            return -1;
        }

        return ret;
    }
```

##### 3.2 机器人路径问题（存在型动态规划）

- 问题描述（<https://www.lintcode.com/problem/114/>）：

    有一个机器人的位于一个 $m\times n$ 个网格左上角。
    机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。
    问有多少条不同的路径？

        样例 1：
        输入：
        n = 1
        m = 3
        输出：
        1

        样例 2：
        输入：
        n = 3
        m = 3
        输出：
        6

- 分析：
  
##### 3.3 背包问题

#### 参考

<div id="refer-anchor-1"></div>

[1] [动态规划-维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
