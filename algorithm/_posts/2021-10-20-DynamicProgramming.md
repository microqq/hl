---
layout: post
title:  "动态规划"
date:   2021-10-20
categories: 
    - algorithm
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

动态规划

- [1. 什么是动态规划](#1-什么是动态规划)
- [2. 怎么理解它](#2-怎么理解它)
  - [2.1 动态规划问题一般有几个特征](#21-动态规划问题一般有几个特征)
  - [2.2 动态规划算法的基本步骤](#22-动态规划算法的基本步骤)
- [3. 动态规划问题](#3-动态规划问题)
  - [3.1 硬币问题（最优型动态规划）](#31-硬币问题最优型动态规划)
  - [3.2 机器人路径问题（计数型动态规划）](#32-机器人路径问题计数型动态规划)
  - [3.3 房屋染色问题（序列型动态规划）](#33-房屋染色问题序列型动态规划)
  - [3.4 背包动态规划问题](#34-背包动态规划问题)
  - [3.5 解码方法问题（划分型动态规划）](#35-解码方法问题划分型动态规划)
  - [3.6 跳跃游戏问题（存在型动态规划）](#36-跳跃游戏问题存在型动态规划)
- [4. 动态规划问题优化](#4-动态规划问题优化)
- [参考](#参考)

#### 1. 什么是动态规划

动态规划是一种解决多阶段过程决策最优化问题的数学方法。

多阶段决策的过程可以按照空间或时间等划分成多个互相联系的阶段，每一个阶段都需要做出决策，决策的选取并不是任意的，它既依赖于当前的状态，又会影响以后阶段决策的发展，这种前后关联的多阶段决策过程就称为多阶段决策问题。

针对多阶段决策问题，20世纪50年代美国数学家Bellmen等人提出了著名的最优化原理，把多阶段过程划分为系列的单阶段过程，利用阶段之间的关联，逐个求解，从而创立了解决这类过程优化问题的新方法——动态规划。当每一个阶段局部决策都是最优的时候，所有阶段决策形成的决策序列就构成了最优全局决策。

动态规划是一种解决问题的方法，而不是一种特殊的解题途径，针对不同的最优化问题，其性质不同，得到最优解的条件也不相同，不存在一种万能的动态规划算法解决所有问题，视具体问题具体分析。

#### 2. 怎么理解它

##### 2.1 动态规划问题一般有几个特征

- 最优子结构性质[<sup>[1]</sup>](#refer-anchor-1)。

如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

- 无后效性[<sup>[1]</sup>](#refer-anchor-1)。

即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

- 子问题重叠性质[<sup>[1]</sup>](#refer-anchor-1)。

子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

##### 2.2 动态规划算法的基本步骤

- 确定状态。

“状态”是什么呢？动态规划在解决多阶段过程决策问题的时候，将其划分成一系列的单阶段决策问题，那么每一个单阶段的决策我们给它设定一个“状态”，比如 $f[i]$ 表示第 $i$ 个阶段的决策“状态”，比如“硬币问题”，状态 $f[i] = Y$ 就表示最少用 $Y$ 枚硬币可以拼出 $i$。
那么该怎么确定“状态”的表示呢？通常我们从多阶段决策问题的最后一个阶段入手，以最优解问题为例，要想使得最后阶段的决策状态 $f[N]$ 是最优的，那么必然要求上一个阶段决策状态 $f[N-1]$ 也是最优的，这样我们将原问题转化成了一个子问题，求解上一个阶段最优决策状态。最后寻找 $f[N]$ 与 $f[N-1]$ 之间的关联，确定“状态”表示，比如 $f[N] = f[N-1] + 1$。

- 确定状态转移方程。

就是要将子问题之间的“状态”关联转化为方程表达式。

- 确定初始条件和边界约束。

初始条件指的是我们计算开始时阶段的“初始状态”，边界约束是指我们处理非法值时的“非法状态”。

- 确定计算顺序。

我们知道多阶段决策问题，每个阶段决策状态都依赖于之前阶段决策状态，所以我们可以根据依赖关系来确定计算顺序，比如“硬币问题”，我们先计算 $f(0)$，然后计算 $f(1),f(2),...,f(i)$。

#### 3. 动态规划问题

##### 3.1 硬币问题（最优型动态规划）

- [问题描述(lintCode-669)](https://www.lintcode.com/problem/669/)：

给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.  

    样例1
    输入：
    [1, 2, 5]
    11
    输出： 3
    解释： 11 = 5 + 5 + 1

    样例2
    输入：
    [2]
    3
    输出： -1

- 分析：
  - 确认状态。

  以样例 1 为例是，最后我们的目标是硬币总额等于11，并且硬币数量最少，我们可以设最后的“状态”为 $f(11) = X$, $X$ 表示最少硬币数量。假设最后一枚硬币是 $a_k(k = 1, 2, 5)$, 这样，要想使 $f(11)$ 数量最少，就要使 $f(11 - a_k)$ 数量最少，两者关联：$f(11) = f(11 - a_k) + 1$。最后一枚硬币 $a_k$ 面额可能是 1、2 和 5 其中之一。

  $$
  f(11) = X_1 = f(11 - 1) + 1,\\
  f(11) = X_2 = f(11 - 2) + 1,\\
  f(11) = X_3 = f(11 - 5) + 1.
  $$

  $f(11)$ 取 $X_1, X_2, X_3$ 中最优的结果。

  - 确定状态转移方程。

  状态方程 $f(i) = X$，自变量 $i$ 表示当前阶段总金额，因变量 $X$ 表示当前阶段硬币数量，状态转移方程为:

  $$
  f(i) = min(f(i - a_0) + 1, f(i- a_1) + 1, f(i - a_2) + 1,...,f(i - a_k) + 1).
  $$

  - 确定初始条件和边界约束。

  首先，从状态转移方程反推计算过程中，我们需要知道计算什么时候停下来，当硬币总额小于 0 时，找不到这样的面额去表示小于 0 的数，因此不需要继续计算了，并且当硬币总额等于 0 时，设 $f(0) = 0$即为初始条件。
  另外，参照状态转移方程，考虑:

  $$
  \begin{align*}
  f(1) &= min(f(1 - 1) + 1, f(1 - 2) + 1, f(1 - 5) + 1) \\
  &= min(f(0) + 1, f(-1) + 1, f(-4) + 1)
  \end{align*}
  $$

  $f(-1)、f(-4)$ 自变量分别等于 $-1、-4$，属于边界以外（小于0）的值，我们设定所有小于 0 的 $f(i) = \infty, (i < 0)$，可得:

  $$
  \begin{align*}
  f(1) &= min(f(1 - 1) + 1, f(1 - 2) + 1, f(1 - 5) + 1) \\
  &= min(f(0) + 1, f(-1) + 1, f(-4) + 1) \\
  &= min(1, \infty, \infty) \\
  &= 1.
  \end{align*}
  $$

- 代码实现：

```C++
#include <vector>
#include <limits>

using namespace std;

const int kIntMax = numeric_limits<int>::max();

int coinChange(vector<int> &coins, int amount) {
    if (coins.size() == 0 || amount == 0) {
        return 0;
    }

    int *f = new int[amount + 1];
    f[0] = 0;
    for (int i = 1; i <= amount; i++) {
        f[i] = kIntMax;
        for (int j = 0, size = coins.size(); j < size; j++) {
            if (i >= coins[j] && f[i - coins[j]] != kIntMax) {
                f[i] = min(f[i - coins[j]] + 1, f[i]);
            }
        }
    }

    int ret = f[amount];
    delete[] f;

    if (ret == kIntMax) {
        return -1;
    }

    return ret;
}
```

##### 3.2 机器人路径问题（计数型动态规划）

- [问题描述(lintCode-114)](https://www.lintcode.com/problem/114/)

有一个机器人的位于一个 $m\times n$ 个网格左上角。
机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。
问有多少条不同的路径？

    样例 1：
    输入：
    n = 1
    m = 3
    输出：
    1

    样例 2：
    输入：
    n = 3
    m = 3
    输出：
    6

- 分析：
  
如果不用动态规划思考这个问题，简单且暴力的做法是遍历所有的可能性，题目要求机器人从左上角到右下角，那么机器人在到达右下角之前，只可能往右和往下移动，机器人在每个网格中都有两种移动方式，当一种移动方式行不通时，就要尝试另一种，如果两种方式都行不通时，机器人就要回退到上一个网格，这就是回溯法。回溯法的缺点是需要试错，而试错要付出代价。

如果用动态规划该怎么思考这个问题呢？  
**首先，确定状态**。题目问机器人从 $m\times n$网格的左上角，每一次向下或向右移动，到右下角有多少种方式，先看最后一步，右下角坐标是 $(m-1,n-1)$，机器人到达右下角只有两种移动方式：向右或者向下，我们来分析这两种情形：

最后一步向右，那么上一步机器人的坐标是 $(m-1, n-2)$，假设机器人到达坐标 $(m-1, n-2)$ 有 $Y_1$ 种方式，那么这时候从 $(m-1, n-2)$ 到右下角有 $Y_1$ 种方式。
最后一步向下，那么上一步机器人的坐标是 $(m-2, n-1)$，假设机器人到达坐标 $(m-2, n-1)$ 有 $Y_2$ 种方式，那么这时候从 $(m-2, n-1)$ 到右下角有 $Y_2$ 种方式。

那么机器人到达右下角总共有 $X = (Y_1+ Y_2)$ 种方式，我们用 $f(m-1, n-1) = X$ 表示机器人到达右下角的“状态”——有 $X$ 种方式， $f(m-1, n-2) = Y_1$ 表示机器到达坐标 $(m-1, n-2)$ 有 $Y_1$ 种方式， $f(m-2, n-1) = Y_2$ 表示机器到达坐标 $(m-2, n-1)$ 有 $Y_2$ 种方式。要求解 $X$，只需要求解 $Y_1$ 和 $Y_2$ 即可，于是原问题从求取机器人到达右下角有多少种方式变成了机器人到达坐标 $(m-1,n-2)$ 和 $(m-2,n-1)$ 分别有多少种方式。

$$
f(m-1,n-1) = f(m-1,n-2) + f(m-2,n-1).
$$

设 $0\leq i \leq m-1$，$0\leq j \leq n-1$，则 $f(i,j) = N$ 表示机器人有 $N$ 种方式可以到达坐标 $(i,j)$ 。

**确认状态转移方程**。上面确认决策状态时可以看到，求解 $X$ 的问题变成了求解 $Y_1$ 和 $Y_2$，同理，求解 $Y_1$ 或者 $Y_2$ 也可以变成求解更小的 $Y_{11}$、 $Y_{12}$ 或者 $Y_{21}$、 $Y_{22}$ 问题，一直到问题“解”可以直接得到。用“状态”方程来表示它们之间的关联关系：

$$
f(i,j) = f(i-1,j) + f(i,j-1).
$$

**初始条件和边界约束**。初始时机器人在$(0,0)$位置，$f(0,0)=1$。题目中机器人只能向右或者向下移动，可以观察到，机器人只有一种方式能到达第一行或者第一列，状态表示为：

$$
f(i,j) = 1,(i=0)\\
f(i,j) = 1,(j=0).
$$

**确认计算顺序**，根据状态转移方程，要求解状态 $f(i,j)$，那么需要知道 $(i-1,j)$ 和 $(i,j-1)$ 的状态，也就是要知道前 $i$ 行和前 $j$ 列所有的状态，所以，我们计算时从左到右，从上到下，按行计算即可。

- 代码实现

```C++
int robotPaths(int m, int n) {
    if (m <= 0 || n <= 0) {
        return 0;
    }

    int f[m][n];
    f[0][0] = 1;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                f[i][j] = 1;
            } else {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
    }

    return f[m - 1][n - 1];
}
```

##### 3.3 房屋染色问题（序列型动态规划）

- [问题描述(lintCode-515)](https://www.lintcode.com/problem/515/)

这里有n个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小，返回最小的费用。

费用通过一个 nx3 的矩阵给出，比如cost[0][0]表示房屋0染红色的费用，cost[1][2]表示房屋1染绿色的费用，依此类推。找到油漆所有房子的最低成本。

所有费用都是正整数？

    样例 1:
    输入: [[14,2,11],[11,14,5],[14,3,10]]
    输出: 10
    解释: 第一个屋子染蓝色，第二个染绿色，第三个染蓝色，最小花费：2 + 5 + 3 = 10.

    样例 2:
    输入: [[1,2,3],[1,4,6]]
    输出: 3

- 分析：

##### 3.4 背包动态规划问题

##### 3.5 解码方法问题（划分型动态规划）

- [问题描述(lintCode-512)](https://www.lintcode.com/problem/512/)：

有一个消息包含A-Z通过以下规则编码
'A' -> 1
'B' -> 2
...
'Z' -> 26
现在给你一个加密过后的消息，问有几种解码的方式

    样例 1:
    输入: "12"
    输出: 2
    解释: 它可以被解码为 AB (1 2) 或 L (12).

    样例 2:
    输入: "10"
    输出: 1

- 分析：

##### 3.6 跳跃游戏问题（存在型动态规划）

- [问题描述(lintCode-116)](https://www.lintcode.com/problem/116/)：

给出一个非负整数数组，你最初定位在数组的第一个位置。
数组中的每个元素代表你在那个位置可以跳跃的最大长度。
判断你是否能到达数组的最后一个位置。

    数组A的长度不超过5000，每个元素的大小不超过5000

    样例 1：
    输入：
    A = [2,3,1,1,4]
    输出：
    true
    解释：
    0 -> 1 -> 4（这里的数字为下标）是一种合理的方案。

    样例 2：
    输入：
    A = [3,2,1,0,4]
    输出：
    false
    解释：
    不存在任何方案能够到达终点。

- 分析：

#### 4. 动态规划问题优化

#### 参考

<div id="refer-anchor-1"></div>

[1] [动态规划-维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
