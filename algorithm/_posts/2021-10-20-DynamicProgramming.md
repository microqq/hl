---
layout: post
title:  "动态规划"
date:   2021-10-20
categories: 
    - algorithm
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
    <link href="/static/css/rouge.css" rel="stylesheet"/>
</head>

动态规划

- [1. 什么是动态规划](#1-什么是动态规划)
- [2. 怎么理解它](#2-怎么理解它)
  - [2.1 动态规划问题一般有几个特征](#21-动态规划问题一般有几个特征)
  - [2.2 动态规划算法的基本步骤](#22-动态规划算法的基本步骤)
- [3. 动态规划问题](#3-动态规划问题)
  - [3.1 硬币问题（最优型动态规划）](#31-硬币问题最优型动态规划)
  - [3.2 机器人路径问题（计数型动态规划）](#32-机器人路径问题计数型动态规划)
  - [3.3 房屋染色问题（序列型动态规划）](#33-房屋染色问题序列型动态规划)
  - [3.4 背包动态规划问题](#34-背包动态规划问题)
  - [3.5 解码方法问题（划分型动态规划）](#35-解码方法问题划分型动态规划)
  - [3.6 跳跃游戏问题（存在型动态规划）](#36-跳跃游戏问题存在型动态规划)
- [4. 动态规划问题优化](#4-动态规划问题优化)
- [参考](#参考)

#### 1. 什么是动态规划

动态规划是一种解决多阶段过程决策最优化问题的数学方法。

多阶段决策的过程可以按照空间或时间等划分成多个互相联系的阶段，每一个阶段都需要做出决策，决策的选取并不是任意的，它既依赖于当前的状态，又会影响以后阶段决策的发展，这种前后关联的多阶段决策过程就称为多阶段决策问题。

针对多阶段决策问题，20世纪50年代美国数学家Bellmen等人提出了著名的最优化原理，把多阶段过程划分为系列的单阶段过程，利用阶段之间的关联，逐个求解，从而创立了解决这类过程优化问题的新方法——动态规划。当每一个阶段局部决策都是最优的时候，所有阶段决策形成的决策序列就构成了最优全局决策。

动态规划是一种解决问题的方法，而不是一种特殊的解题途径，针对不同的最优化问题，其性质不同，得到最优解的条件也不相同，不存在一种万能的动态规划算法解决所有问题，视具体问题具体分析。

#### 2. 怎么理解它

##### 2.1 动态规划问题一般有几个特征

- 最优子结构性质[<sup>[1]</sup>](#refer-anchor-1)。

如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

- 无后效性[<sup>[1]</sup>](#refer-anchor-1)。

即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

- 子问题重叠性质[<sup>[1]</sup>](#refer-anchor-1)。

子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

##### 2.2 动态规划算法的基本步骤

- 确定状态。

“状态”是什么呢？动态规划在解决多阶段过程决策问题的时候，将其划分成一系列的单阶段决策问题，那么每一个单阶段的决策我们给它设定一个“状态”，比如 $f[i]$ 表示第 $i$ 个阶段的决策“状态”，比如“硬币问题”，状态 $f[i] = Y$ 就表示最少用 $Y$ 枚硬币可以拼出 $i$。
那么该怎么确定“状态”的表示呢？通常我们从多阶段决策问题的最后一个阶段入手，以最优解问题为例，要想使得最后阶段的决策状态 $f[n]$ 是最优的，那么必然要求上一个阶段决策状态 $f[n-1]$ 也是最优的，这样我们将原问题转化成了一个子问题，求解上一个阶段最优决策状态。最后寻找 $f[n]$ 与 $f[n-1]$ 之间的关联，确定“状态”表示，比如 $f[n] = f[n-1] + 1$。

- 确定状态转移方程。

就是要将子问题之间的“状态”关联转化为方程表达式。

- 确定初始条件和边界约束。

初始条件指的是我们计算开始时阶段的“初始状态”，边界约束是指我们处理非法值时的“非法状态”。

- 确定计算顺序。

我们知道多阶段决策问题，每个阶段决策状态都依赖于之前阶段决策状态，所以我们可以根据依赖关系来确定计算顺序，比如“硬币问题”，我们先计算 $f(0)$，然后计算 $f(1),f(2),...,f(i)$。

#### 3. 动态规划问题

##### 3.1 硬币问题（最优型动态规划）

- [问题描述(lintCode-669)](https://www.lintcode.com/problem/669/)：

给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.  

    样例1
    输入：
    [1, 2, 5]
    11
    输出： 3
    解释： 11 = 5 + 5 + 1

    样例2
    输入：
    [2]
    3
    输出： -1

- 分析：

**确认状态**，以样例 1 为例是，最后我们的目标是硬币总额等于11，并且硬币数量最少，我们可以设最后的“状态”为 $f(11) = X$, $X$ 表示最少硬币数量。假设最后一枚硬币是 $a_k(k = 1, 2, 5)$, 这样，要想使 $f(11)$ 数量最少，就要使 $f(11 - a_k)$ 数量最少，两者关联：$f(11) = f(11 - a_k) + 1$。最后一枚硬币 $a_k$ 面额可能是 1、2 和 5 其中之一。

  $$
  f(11) = X_1 = f(11 - 1) + 1,\\
  f(11) = X_2 = f(11 - 2) + 1,\\
  f(11) = X_3 = f(11 - 5) + 1.
  $$

  $f(11)$ 取 $X_1, X_2, X_3$ 中最优的结果。

**确定状态转移方程**。状态方程 $f(i) = X$，自变量 $i$ 表示当前阶段总金额，因变量 $X$ 表示当前阶段硬币数量，状态转移方程为:

  $$
  f(i) = min(f(i - a_0) + 1, f(i- a_1) + 1, f(i - a_2) + 1,...,f(i - a_k) + 1).
  $$

**确定初始条件和边界约束**。首先，从状态转移方程反推计算过程中，我们需要知道计算什么时候停下来，当硬币总额小于 0 时，找不到这样的面额去表示小于 0 的数，因此不需要继续计算了，并且当硬币总额等于 0 时，设 $f(0) = 0$即为初始条件。
另外，参照状态转移方程，考虑:

  $$
  \begin{align*}
  f(1) &= min(f(1 - 1) + 1, f(1 - 2) + 1, f(1 - 5) + 1) \\
  &= min(f(0) + 1, f(-1) + 1, f(-4) + 1)
  \end{align*}
  $$

$f(-1)、f(-4)$ 自变量分别等于 $-1、-4$，属于边界以外（小于0）的值，我们设定所有小于 0 的 $f(i) = \infty, (i < 0)$，可得:

  $$
  \begin{align*}
  f(1) &= min(f(1 - 1) + 1, f(1 - 2) + 1, f(1 - 5) + 1) \\
  &= min(f(0) + 1, f(-1) + 1, f(-4) + 1) \\
  &= min(1, \infty, \infty) \\
  &= 1.
  \end{align*}
  $$

**代码实现**，

~~~C++
#include <vector>
#include <limits>

using namespace std;

const int kIntMax = numeric_limits<int>::max();

int coinChange(vector<int> &coins, int amount) {
    if (coins.size() == 0 || amount == 0) {
        return 0;
    }

    int *f = new int[amount + 1];
    f[0] = 0;
    for (int i = 1; i <= amount; i++) {
        f[i] = kIntMax;
        for (int j = 0, size = coins.size(); j < size; j++) {
            if (i >= coins[j] && f[i - coins[j]] != kIntMax) {
                f[i] = min(f[i - coins[j]] + 1, f[i]);
            }
        }
    }

    int ret = f[amount];
    delete[] f;

    if (ret == kIntMax) {
        return -1;
    }

    return ret;
}
~~~

##### 3.2 机器人路径问题（计数型动态规划）

- [问题描述(lintCode-114)](https://www.lintcode.com/problem/114/)

有一个机器人的位于一个 $m\times n$ 个网格左上角。
机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。
问有多少条不同的路径？

    样例 1：
    输入：
    n = 1
    m = 3
    输出：
    1

    样例 2：
    输入：
    n = 3
    m = 3
    输出：
    6

- 分析：
  
如果不用动态规划思考这个问题，简单且暴力的做法是遍历所有的可能性，题目要求机器人从左上角到右下角，那么机器人在到达右下角之前，只可能往右和往下移动，机器人在每个网格中都有两种移动方式，当一种移动方式行不通时，就要尝试另一种，如果两种方式都行不通时，机器人就要回退到上一个网格，这就是回溯法。回溯法的缺点是需要试错，而试错要付出代价。

如果用动态规划该怎么思考这个问题呢？  
**首先，确定状态**。题目问机器人从 $m\times n$网格的左上角，每一次向下或向右移动，到右下角有多少种方式，先看最后一步，右下角坐标是 $(m-1,n-1)$，机器人到达右下角只有两种移动方式：向右或者向下，我们来分析这两种情形：

最后一步向右，那么上一步机器人的坐标是 $(m-1, n-2)$，假设机器人到达坐标 $(m-1, n-2)$ 有 $Y_1$ 种方式，那么这时候从 $(m-1, n-2)$ 到右下角有 $Y_1$ 种方式。
最后一步向下，那么上一步机器人的坐标是 $(m-2, n-1)$，假设机器人到达坐标 $(m-2, n-1)$ 有 $Y_2$ 种方式，那么这时候从 $(m-2, n-1)$ 到右下角有 $Y_2$ 种方式。

那么机器人到达右下角总共有 $X = (Y_1+ Y_2)$ 种方式，我们用 $f(m-1, n-1) = X$ 表示机器人到达右下角的“状态”——有 $X$ 种方式， $f(m-1, n-2) = Y_1$ 表示机器到达坐标 $(m-1, n-2)$ 有 $Y_1$ 种方式， $f(m-2, n-1) = Y_2$ 表示机器到达坐标 $(m-2, n-1)$ 有 $Y_2$ 种方式。要求解 $X$，只需要求解 $Y_1$ 和 $Y_2$ 即可，于是原问题从求取机器人到达右下角有多少种方式变成了机器人到达坐标 $(m-1,n-2)$ 和 $(m-2,n-1)$ 分别有多少种方式。

$$
f(m-1,n-1) = f(m-1,n-2) + f(m-2,n-1).
$$

设 $0\leq i \leq m-1$，$0\leq j \leq n-1$，则 $f(i,j) = n$ 表示机器人有 $n$ 种方式可以到达坐标 $(i,j)$ 。

**确认状态转移方程**。上面确认决策状态时可以看到，求解 $X$ 的问题变成了求解 $Y_1$ 和 $Y_2$，同理，求解 $Y_1$ 或者 $Y_2$ 也可以变成求解更小的 $Y_{11}$、 $Y_{12}$ 或者 $Y_{21}$、 $Y_{22}$ 问题，一直到问题“解”可以直接得到。用“状态”方程来表示它们之间的关联关系：

$$
f(i,j) = f(i-1,j) + f(i,j-1).
$$

**初始条件和边界约束**。初始时机器人在$(0,0)$位置，$f(0,0)=1$。题目中机器人只能向右或者向下移动，可以观察到，机器人只有一种方式能到达第一行或者第一列，状态表示为：

$$
f(i,j) = 1,(i=0)\\
f(i,j) = 1,(j=0).
$$

**确认计算顺序**，根据状态转移方程，要求解状态 $f(i,j)$，那么需要知道 $(i-1,j)$ 和 $(i,j-1)$ 的状态，也就是要知道前 $i$ 行和前 $j$ 列所有的状态，所以，我们计算时从左到右，从上到下，按行计算即可。

**代码实现**

```C++
int robotPaths(int m, int n) {
    if (m <= 0 || n <= 0) {
        return 0;
    }

    int f[m][n];
    f[0][0] = 1;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                f[i][j] = 1;
            } else {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
    }

    return f[m - 1][n - 1];
}
```

##### 3.3 房屋染色问题（序列型动态规划）

- [问题描述(lintCode-515)](https://www.lintcode.com/problem/515/)

这里有n个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小，返回最小的费用。

费用通过一个 nx3 的矩阵给出，比如cost[0][0]表示房屋0染红色的费用，cost[1][2]表示房屋1染绿色的费用，依此类推。找到油漆所有房子的最低成本。

所有费用都是正整数？

    样例 1:
    输入: [[14,2,11],[11,14,5],[14,3,10]]
    输出: 10
    解释: 第一个屋子染蓝色，第二个染绿色，第三个染蓝色，最小花费：2 + 5 + 3 = 10.

    样例 2:
    输入: [[1,2,3],[1,4,6]]
    输出: 3

- 分析：

这里提供两种不同的思路：

1. 同样的分析套路，先看第一种思路。首先**确认状态**，本题的最后阶段决策“状态”是使得最后一套房子涂上红、蓝或绿某一种颜色后，所有房子染色花费最小，用 $f(n-1, j) = C$ 来表示（房子序号 $i = 0,1,2,...,n-1$，共 $n$ 栋房子， $n - 1$ 是房子序号，$j$ 表示第 $n-1$ 栋房子染上 $j$ 颜色）。显然，要使得 $f(n-1, j)$ 花费最小，那么必须使第 $n-2$ 栋房子染色后，前 $n-1$ 栋房子花费最小，

$$
f(n-1, j) = min(f(n-2, k) + cost(n-1, j)), (j \in (0, 1, 2), k \neq j)
$$

于是原问题由求 $n$ 栋房子染色花费最小变成了求 $n-1$ 栋房子染色花费最小。

**确认状态转移方程**，由上述状态表示确认状态转移方程：

$$
f(i, j) = min(f(i-1, k) + cost(i, j)), (i \in (0,1,2,...,n-1), j \in (0, 1, 2), k \neq j)
$$

**初始条件和边界约束**，从状态转移方程中可以知道，从后往前推导决策状态，一直到 $f(0,j)$ 状态—— 第 $0$ 栋房子染色后的最小花费，计算停止。

$$
f(0,j) = cost(0,j), (j \in (0,1,2))
$$

$f(0,j)$ 等于单套房子染色花费。

**计算顺序**，从第 $0$ 套房子开始计算每个阶段决策状态。$min(f(n-1, j))$ —— 即为最终的解。

**代码实现**,
```C++
int minCost(vector<vector<int>> &costs) {
  int rows = costs.size();
  if (rows == 0) {
      return 0;
  }

  const int kIntMax = std::numeric_limits<int>::max();
  int f[rows][3];
  for (int j = 0; j < 3; j++) {
      f[0][j] = costs[0][j];
  }

  for (int i = 1; i < rows; i++) {
      for (int j = 0; j < 3; j++) {
          f[i][j] = kIntMax;
          for (int k = 0; k < 3; k++) {
              if (k != j) {
                  f[i][j] = min(f[i][j], f[i-1][k] + costs[i][j]);
              }
          }
      }
  }

  return min(f[rows - 1][0], min(f[rows - 1][1], f[rows - 1][2]));
}
```

2[<sup>[2]</sup>](#refer-anchor-2). 其实上面第一种思路，从后往前推导决策状态的过程中，我们是在确定最后一套房子的颜色后，根据最后一套房子所染颜色色选择了倒数第二套房子应该染上什么颜色。问题同样被解决了，但是思考一下，前面说了动态规划是一种解决多阶段决策问题的方法，而每一个阶段的决策选取不是任意的，它依赖于当前的决策状态，又会影响后期的决策选择，并且动态规划有一个性质是“无后效性”，也就是说每个阶段做出决策后，不会受到后面阶段决策的影响。因此，最后一套房子所染颜色应该由倒数第二套房子所染颜色来决定，怎么样才能决定最后一套房子的颜色呢？

**确认状态**，如果我们设状态 $f(n, j)$ —— 表示为 $n$ 套房子（所有房子）都染色了，且第 $n-1$ 套房子染成 $j$ 颜色后的最小花费，这样第 $n$ 套房子就能根据第 $n-1$ 套房子所染颜色确定，。为什么设 $f(n,j)$ 而不是 $f(n-1, j)$ 表示最后一套房子染色后的状态？考虑状态 $f(0, j)$ —— 表示 $0$ 套房子染色后，且第 $-1$ 房子染成 $j$ 颜色后的最小花费，显然这是不合理的，因此如果有 $n$ 套房子，我们设房子序号 $i \in (0,1,2,...,n)$，初始时不染色任何房子 $f(0,j) = 0$。$f(i,j)$ 表示共 $i$ 套房子染色最小花费，并记录了第 $i-1$ 套房子所染颜色。

**确认状态转移方程**

$$
\begin{cases}
\begin{aligned}
& C = costs(i, j), (i \in (0,1,2,...,n-1), j \in (0,1,2))\\
& f(i,j) = min(f(i-1, k_1) + C, f(i-1, k_2) + C), (i \in 1,2,3,...,n), j \in (0,1,2))\\
& f(i,j), (i \in (0),  j \in (0,1,2)) = 0
\end{aligned}
\end{cases}
$$

**初始条件与边界约束**，上文其实已经列出了初始条件 $f(0,j) = 0$，并且没有额外的边界约束。

**计算顺序**，按照从左到右，从上到下的顺序计算即可。

**代码实现**,
```C++
int minCost(vector<vector<int>> &costs) {
  int rows = costs.size();
  if (rows == 0) {
      return 0;
  }

  const int kIntMax = std::numeric_limits<int>::max();
  int f[rows + 1][3]{0};

  for (int i = 1; i <= rows; i++) {
      for (int j = 0; j < 3; j++) {
          f[i][j] = kIntMax;
          for (int k = 0; k < 3; k++) {
              if (k != j) {
                  f[i][j] = min(f[i][j], f[i-1][k] + costs[i-1][k]);
              }
          }
      }
  }

  return min(f[rows][0], min(f[rows][1], f[rows][2]));
}
```

##### 3.4 背包动态规划问题

##### 3.5 解码方法问题（划分型动态规划）

- [问题描述(lintCode-512)](https://www.lintcode.com/problem/512/)：

有一个消息包含A-Z通过以下规则编码
'A' -> 1
'B' -> 2
...
'Z' -> 26
现在给你一个加密过后的消息，问有几种解码的方式

    样例 1:
    输入: "12"
    输出: 2
    解释: 它可以被解码为 AB (1 2) 或 L (12).

    样例 2:
    输入: "10"
    输出: 1

- 分析：

**确认状态**，从第一个字符开始到最后一个字符，依次解码，我们想知道有多少种方式解码字符串，当解码进行到最后一个字符时，我们设 $f(n)$ 表示字符串 $n$ 个字符的解码方式数，又设 $f(n-1)$ 表示字符串 $n-1$ 个字符的解码方式数，又因为，最后一个字符可以和倒数第二个字符结合起来，所以有，

$$
f(n) = f(n-1) + f(n-2).
$$

求解 $n$ 个字符解码方式的问题变成了求解 $n-1$ 和 $n-2$ 个字符解码方式的问题。

**确认状态转移方程**，根据上面原问题与子问题的关联，获得状态转移方程，

$$
f(i) = f(i-1) + f(i-2), (i \in (2,3,...,n)).
$$

**初始条件和边界约束**，根据状态转移方程，设$0$ 个字符长度的字符串即空串的解码方式数等于 $1$，$1$ 个字符长度的字符串解码方式必然只有 $1$ 种，因此有初始条件，

$$
\begin{cases}
f(0) = 1,\\
f(1) = 1.
\end{cases}
$$

边界约束，有三种特殊情形需要考虑，一是当编码串中某个字符数字等于 $0$，那么该字符必须与前一个字符结合起来；二是当编码串中相邻的字符数字大于 $26$ 时，相邻字符是不能结合的；三是编码串中出现连续的数字 $0$ 时，编码串解码方式数应为 $0$。

**计算顺序**，我们从第 $2$ 个字符开始计算。

**代码实现**，
```C++
int numDecodings(string &s) {
    int length = s.length();
    if (length == 0 || s[0] == '0') {
        return 0;
    }

    int f[length + 1]{0};
    f[0] = f[1] = 1;

    for (int i = 2; i <= length; i++) {
        if (s[i-1] == '0') {
            if (s[i-2] == '0' ||
                s[i-2] >= '3') {
                return 0;
            }
            f[i] = f[i-2];
        } else {
            if (s[i-2] == '2' && s[i-1] <= '6' ||
                s[i-2] == '1') {
                f[i] = f[i-1] + f[i-2];
            } else {
                f[i] = f[i-1];
            }
        }
    }

    return f[length];
}
```

##### 3.6 跳跃游戏问题（存在型动态规划）

- [问题描述(lintCode-116)](https://www.lintcode.com/problem/116/)：

给出一个非负整数数组，你最初定位在数组的第一个位置。
数组中的每个元素代表你在那个位置可以跳跃的最大长度。
判断你是否能到达数组的最后一个位置。

    数组A的长度不超过5000，每个元素的大小不超过5000

    样例 1：
    输入：
    A = [2,3,1,1,4]
    输出：
    true
    解释：
    0 -> 1 -> 4（这里的数字为下标）是一种合理的方案。

    样例 2：
    输入：
    A = [3,2,1,0,4]
    输出：
    false
    解释：
    不存在任何方案能够到达终点。

- 分析：

**确认状态**，假设数组长度为 $n$，以"状态" $f(n-1) = X, (x = True\space or\space False)$ 表示能否到达数组的最后一个位置，假设当前在 $n-2$ 的位置，要想能够到达数组最后一个位置，那么在 $n-2$ 的位置能够跳跃的最大长度必须大于等于 $1$，同理，假设当前在 $n-3$ 的位置，要想能够到达数组最后一个位置，那么此时能够跳跃的最大长度必须大于等于 $2$，因此，我们可以得到在 $n-1$ 位置时“状态”与其他位置“状态”的关联关系，

$$
\begin{aligned}
f(n-1) = &f(n-2) \space and\space (a_{n-2} \geq 1) \space or\\
&f(n-3) \space and\space (a_{n-3} \geq 2) \space or\\
&... \space or\\
&f(0) \space and\space (a_{0} \geq n-1)
\end{aligned}
$$

**确认状态转移方程**，由状态关联关系，我们得到状态转移方程，

$$
\begin{aligned}
f(i) = &f(i-1) \space and\space (a_{i-1} \geq 1) \space or\\
&f(i-2) \space and\space (a_{i-2} \geq 2) \space or\\
&..., (i \in (0,1,2,...,n-1))
\end{aligned}
$$

**初始条件和边界约束**，开始我们位于 $0$ 位置，因此 $f(0) = true$。当目标位置与当前位置的距离超出了当前位置的最大跳跃距离时，就表明从当前位置无法到达目标位置。

**代码实现**,
```C++
bool canJump(vector<int> &A) {
    int length = A.size();
    if (length == 0) {
        return false;
    }

    bool f[length]{false};
    f[0] = true;

    for (int i = 1; i < length; i++) {
        for (int j = 0; j < i; j++) {
            if (!f[j]) {
                f[i] |= (f[j] && (i - j) <= A[j]);
                continue;
            }

            break;
        }
    }

    return f[length - 1];
}
```

#### 4. 动态规划问题优化

#### 参考

<div id="refer-anchor-1"></div>

[1] [动态规划-维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

<div id="refer-anchor-2"></div>

[2] [动态规划算法-Bilibili](https://www.bilibili.com/video/BV1nt4y1Y7n7?spm_id_from=333.999.0.0)

<div id="refer-anchor-3"></div>

[3]《背包九讲》